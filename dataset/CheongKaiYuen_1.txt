
Title
Unconditionally Secure Oblivious Transfer Based
on Channel Delays

Issue Date 2011-11-01

Abstract Without the use of computational assumptions uncondition
ally secure oblivious transfer 
OT is impossible in the standard model
where the parties are using a clear channel	 Such impossibilities can be
overcome by using a noisy channel	 Recently Palmieri and Pereira pro
posed a protocol based on random channel delays only	 Their scheme is
secure in the semihonest model but not in the general malicious model	
In this paper we study oblivious transfer in the same setting but we im
prove the result to obtain a fully secure protocol in the malicious model	
Keywords oblivious transfer unconditional security channel delay
?? Introduction
Oblivious Transfer OT is a twoparty cryptographic protocol with a simple
function However it is an important primitive because any secure computation
can be based on OT  		
 It is considered a universal primitive for crypto
graphic functionalities where the users do not fully trust each other
In the rst OT system introduced by Rabin 
 a message is received with
probability 	           
  ナ     	 マヤ 
 where the sender has two
secrets and the receiver can choose one of them in an oblivious manner That is
the sender cannot know the receivers choice and the receiver cannot know more
than one of the senders secrets The 	outof マヤ     メ
マヤ 	
 チ           
	 マヤ           


ツ        マヤ   
          
 ノ            
  マヤ         	
 ラ
マヤ          
 	 ミ  ミ 
        
     ノ       
 ヒル テ  チ ヘ
         ヤ     
           
     ノ
ノ 
   マヤ        
           
  ノ         
  ヤ      モ 
       
   マヤ 
マ      モ     
           マヤ ノ モ
             
     
 ヤ        
モ            
モ 
 ミ
ソソ ト テ
ニ    
         
     ツトトテ ノ    
           ノ 
          
      ヤ   
             
    チ          
     ヤ       
チ          	 ラ    
      	 ソソ  ホ      
        ヤ ツトトテ  
 
	 ヤ             ヤ 
ソソ      ユ  ソソ  
 チ              マ  
      チ      
           ヤ 
       ソソ ソソ ソソ ニ      
ノ               
ヤ     	     ニ    
    チ          
               
        ノ 
     
  	
ユ モ マ ヤ ツ  テ ト 
ソソソソ マ ヤ
ノ    	  マヤ      
	 ヤ  チ       ソソ     ツ
    
 テ ノ  チ  ツ   ツ    チ
 
 モ  チ メ  ツ   チ    
   	   ツ     ソソ 
 モ  ツ ノ ツ   チ      
   
ノ             
           マヤ   
  チ            
      マ       
          ヤ  
          
 チ   
 モ マヤ
ノ         
 ノ    マヤ 
 チ          ノ
             ヤ
                
 マ     
	 ニ    チ       ニ 
      ニ 	           
            ホ  
 
  	 ソソ 
 チ  ソソ チ      ツトトテ チ      
 ナ
   
        ツトトテ 
 チ  ソソ ツ       ツトトテ ノ  
    ツ   
 マ ツ       ノ  	       
 マヤ       ノ    ツ  
       ソソ     ノ ネ  ノソソ      
  	         ノ
 ツ  ノソソ ノ      チ ノ     
 ツトトテ        ノ      
           
 ヒル テ  チ ヘ
 Alice computes
?? M
iI??
ei
 M
iI
ei 	
and then sets ??  s??  ?? and   s  
 Alice sends ??  to Bob
 Bob knows ei whenever i  Ic He computes c  LiIc
ei and nally
sc  c  c
In essence in the protocol vi is a random message Alice sends to Bob and v
i is
for confusion such that Bob will not be able to get Alices message if he gets vi
and v
i at the same time Thus the setting has the feature of Rabin OT 	
 It is
then used to construct the 	outof マヤ    
ソソ モ    
ニ    マヤ       
        チ    ツ
テ ノ         ソソ  
          ニ 
         ソソ モ  
  
 ネ           
ソソ 

ソソ
 チ            
  
チ  ラ         
  ツ       ツ ヤ  
        ツ     
          ツ     
      ヤ       
        ソソ   ホ    ツ   
     
ニ       
        
ツ         ニ      
    ヤ        	    
 	 ソソ  ホ       
マ         ツ    
 モ    ノソソ    ノ          ツ
  ソソ 
ツ  ノ チ          
         ノソソ ノ   
ヤ         チ
ユ モ マ ヤ ツ  テ ト 
 テ   
 ノ    
ヤ         チ    
 ホ  チ          
          マ
     ツ          
      チ          
  ツトトテ      ヘ チ    
       ツ ヤ      
チ             ソソ  
  ニ         
  
	 チ  
     ソソ
 チ     
  ソソ
 チ     
  ソソ
ヤ        ツ       
       ニ    ツ 
          
  ソソ ヤ   
      ヤ         
   ツ        
    ノソソ ヤ チ   ツ    
    ヤ         
ソソ ヤ  
ユ    
  マヤ        
    マヤ  ツ     チ チ 
   リマメ     ツ       ニ
      
	 チ   チ  マヤ  ソソ   ツ    
 チ      ソソ 	   ソソ ソソ   ソソソソ
 チ  ソソ   フ
 ソソ  ソソ
 チ          ソソ  ソソ     
 ヤ         マヤ ニ     
    ソソ 
 Bob makes the choices randomly except that the XOR of all choices repre
sents the real choice c That is denoting the choices in the OT subprotocols
by ci we have
k
M
i
ci  c 
 ヒル テ  チ ヘ
 ヤ             
 

ヘ

 
ノ     チ          
   ヤ    ツ      
       ツ
ツ             
         
  ツ モ         マヤ 
 ヤ  
ノ         チ  ツ     
マヤ      ヤ       ツ
       ソソ ノ チ    
  
             ソソ 
  ソソ 	            ヤ  
       ソソ 
      チ
    ツ         
         ソソ   ソソ 
 
ヤ   
	 ヤ            チ  
      	      	          
モ   
  	 ソソ  
 チ      ツトトテ  ソソ   
  
 ツ            ネ 
              
	     ネ        
  	  ソソ ネ         
 マ ツ    リ        ニ
	                ソソ
ニ          ツ    ノ 
        ソソ 
  ツ     
リ
 ニ    ツ     リ 	 
 
 If the protocol is not aborted Bob selects cj randomly for 	  j  k except
that
c 
k
M
i
ci 
 For 	  j  k Bob randomly selects a set of indices Ijcj such that jIjcj j 
n      ノ ツ       ソソ ネ 
ノソソ         	         ノ  ツ  
ノソソ ノ  チ
ユ モ マ ヤ ツ  テ ト 
 Alice generates a list of k ?? 	 random bits ?? ??   ??k??
 Alice chooses ??k such that Lk
j ??j  s??
	 Alice sets the second list of bits as j  ??j  s??  s for all j
		 For each j Alice computes
j??  M
iIj??
eij
j  M
iIj
eij 
and then sets j??  ??j  j?? and j  j  j
	 チ   ソソ   ツ
	 ツ      ノ  ネ      
	 ヤ    ツ        
 

ヘ

   
 Security analysis
As usual the proof of security is divided into correctness Alices security and
Bobs security Relying on the security of the subprotocol we show that the
complete protocol has negligible failure probabilities in these three aspects
Correctness Observe that when both parties are honest correctness is en
sured if Bob does not abort the protocol In this case Bob may abort the protocol
in two possible ways The rst possibility is at least one of the k subprotocols
has more than n   ツ       
  
ソソ 

ソソ

     ホ        リ 	 
 ニ
           
  ソソ     ソソ 
   ネ    
 
	



  
ホ       ヤ       
          ホ    
            モ

 
	

ソソ
	



  
    リ 	 
   
ソソ
 ソソ
	
 ヒル テ  チ ヘ
  テ  マ 

  
	

ソソ
	



  		
          



	

ソソ
	



  


 	
ヤ    ソソ
    ヤ   
    
チ  ツ        チ 
               ヤ
      	 ソソ  ヤ     

ツ  ヤ  チ      
           モ    ツ
 メ  チ       
	 ニ    チ     
  ソソ
 ニ    チ     
  ソソ
ラ          チ     
  ソソ
        ヤ チ   
    ヤ        チ    
ノ               
    マ           チ
    
  ソソ       フ  
 チ      ノ        
             ヤ
 	  ソソ        ソソ      
   
ニ            
 ソソ 
    ソソ    
 
	



  	
ノ     チ   ツ   リ 	 
  ラ 
 リ   
       ソソ   
  ラ  ネ     リ   

    


  

ソソソソソソ
	
   
ソソ
 ソソ 



ソソ  ソソ  ソソ  
ソソ
 ソソ 



ソソ  ソソ
	

 ソソ 

 
ユ モ マ ヤ ツ  テ ト 

ソソ
 ソソ 



	 ソソ 

  ソソ




ソソ 	
ユ    	ソソ

    
     
   リ 	 
       
 テ
ラ     チ   ツ 
         マヤ  マ
         マヤ   
ヤ            
    ツ  メ      
    チ      ツトトテ  ラ
             
ヤ        マ	    
  ヤ             
メ
	 テ	 テ ナ       ノ チ
 テ  テメルミヤマ  フホテモ  	 	
	 テ	 テ ナ       ノ チ
 テ  ナユメマテメルミヤ  フホテモ  	 	
	 C	 Crepeau and J	 Kilian Achieving oblivious transfer using weakened security
assumption In Proc IEEE FOCS pp	 	
	 C	 Crepeau K	 Morozov and S	 Wolf Ecient unconditional oblivious transfer
from almost any noisy channel In Fourth Conference on Security in Communica	
tion Networks LNCS  pp	 	
	 C	 Crepeau and G	 Savvides Optimal reductions between oblivious transfers using
interactive hashing In Advances in Cryptology  EUROCRYPT 
 LNCS 
pp	 	
	 モ	 ナ マ	 ヌ  チ	 フ チ     
テ   チテヘ 
 	 	
	 J	 Kilian Founding cryptography on oblivious transfer In Proc 
th ACM Sym	
posium on Theory of Computing pp	 	
	 P	 Palmieri and O	 Pereira Building oblivious transfer on channel delays In Proc
Inscrypt 
 LNCS  	 	
	 ヘ	 メ ネ       ヤ メ ヤメ	
チ テ フ ネ ユ 	
	 ハ	 ラ マ      ノ ヤ  テ
 テ  フホテモ  	 	
	 チ	 ル ミ    ミ 
 ノナナナ モ  ニ	
  テ モ 	 	